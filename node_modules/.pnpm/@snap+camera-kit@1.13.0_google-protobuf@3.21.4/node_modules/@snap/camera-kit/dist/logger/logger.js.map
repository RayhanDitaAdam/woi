{"version":3,"file":"logger.js","sourceRoot":"","sources":["../../src/logger/logger.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,MAAM,CAAC;AAC/B,OAAO,EAAE,OAAO,EAAE,MAAM,mBAAmB,CAAC;AAQ5C,IAAI,iBAAiB,GAAG,IAAI,OAAO,EAAY,CAAC;AAShD,MAAM,CAAC,MAAM,WAAW,GAA6B;IACjD,KAAK,EAAE,CAAC;IACR,IAAI,EAAE,CAAC;IACP,IAAI,EAAE,CAAC;IACP,KAAK,EAAE,CAAC;CACX,CAAC;AAYF,MAAM,UAAU,WAAW;IACvB,OAAO,CAAC,iBAAiB,GAAG,IAAI,OAAO,EAAY,CAAC,CAAC;AACzD,CAAC;AA2CD,MAAM,UAAU,SAAS,CAAC,MAAc;IACpC,OAAO,OAAO,CAAC,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE,EAAE;QACnD,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,QAAe,EAAE,EAAE;YACnC,iBAAiB,CAAC,IAAI,CAAC;gBACnB,IAAI,EAAE,IAAI,IAAI,EAAE;gBAChB,MAAM;gBACN,KAAK;gBACL,QAAQ;aACX,CAAC,CAAC;QACP,CAAC,CAAC;QACF,OAAO,MAAM,CAAC;IAClB,CAAC,EAAE,EAAY,CAAC,CAAC;AACrB,CAAC;AAWD,MAAM,UAAU,SAAS,CAAC,MAA+C;IACrE,IAAI,CAAC,MAAM,IAAI,MAAM,KAAK,MAAM,EAAE;QAC9B,OAAO,UAAU,CAAC;KACrB;IAED,IAAI,MAAM,KAAK,SAAS,EAAE;QACtB,OAAO,OAAO,CAAC;KAClB;IAGD,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;QAE1C,MAAM,SAAS,GAAG,MAAM,CAAC,KAAiB,CAAC,CAAC;QAC5C,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,kBAAkB,KAAK,qDAAqD,CAAC,CAAC;SACjG;KACJ;IAED,OAAO,MAAM,CAAC;AAClB,CAAC;AAQD,MAAM,CAAC,MAAM,UAAU,GAAW;IAC9B,KAAK,EAAE,GAAG,EAAE,GAAE,CAAC;IACf,IAAI,EAAE,GAAG,EAAE,GAAE,CAAC;IACd,IAAI,EAAE,GAAG,EAAE,GAAE,CAAC;IACd,KAAK,EAAE,GAAG,EAAE,GAAE,CAAC;CAClB,CAAC","sourcesContent":["import { Subject } from \"rxjs\";\nimport { entries } from \"../common/entries\";\n\n/**\n * A reference to the recently created log messages subject.\n * The subject is overridden in resetLogger() method, which is called during CameraKit bootstrapping.\n *\n * @internal\n */\nlet logEntriesSubject = new Subject<LogEntry>();\n\n/**\n * This map associates log level names with their corresponding level value.\n * This means that a configured log level will match all log entries with a level value greater than\n * or equal to the configured value.\n *\n * @internal\n */\nexport const logLevelMap: Record<LogLevel, number> = {\n    error: 3,\n    warn: 2,\n    info: 1,\n    debug: 0,\n};\n\n/**\n * Initializes a new logger subject.\n *\n * Note: currently only one `CameraKit` instance is allowed to listen to log messages at a time, therefore that is\n * necessary to avoid sharing the same subject between multiple `CameraKit` instances by calling`resetLogger()`.\n * Also, `resetLogger()` should be called when there is no interest in logged messages.\n * This allows the previous logEntriesSubject to be GCec.\n *\n * @internal\n */\nexport function resetLogger() {\n    return (logEntriesSubject = new Subject<LogEntry>());\n}\n\n/**\n * @internal\n */\nexport interface LogEntry {\n    time: Date;\n    module: string;\n    level: keyof Logger;\n    messages: any[];\n}\n\n/**\n * Defines the available logging levels for the Camera Kit SDK.\n *\n * Possible values are:\n * - `\"error\"` - Log only errors (most restrictive)\n * - `\"warn\"` - Log warnings and errors\n * - `\"info\"` - Log informational messages, warnings, and errors\n * - `\"debug\"` - Log all messages including debug information (most verbose)\n *\n * When a log level is set, all messages at that level and higher priority levels will be logged.\n * For example, setting the log level to `\"warn\"` will log warnings and errors, but not info or debug messages.\n */\nexport type LogLevel = \"error\" | \"warn\" | \"info\" | \"debug\";\n\n/**\n * A logger interface that provides methods for logging messages at different severity levels.\n *\n * Each method corresponds to a {@link LogLevel} and accepts a message with optional additional parameters.\n * All logged messages are emitted through the internal logging subject and can be consumed by configuring\n * a logger in the Camera Kit configuration.\n */\nexport type Logger = Record<LogLevel, (message?: any, ...optionalParams: any[]) => void>;\n\n/**\n * Gets logger for a given module.\n *\n * @internal\n *\n * @param module Module name.\n * @returns Logger instance.\n */\nexport function getLogger(module: string): Logger {\n    return entries(logLevelMap).reduce((logger, [level]) => {\n        logger[level] = (...messages: any[]) => {\n            logEntriesSubject.next({\n                time: new Date(),\n                module,\n                level,\n                messages,\n            });\n        };\n        return logger;\n    }, {} as Logger);\n}\n\n/**\n * Maps a logger configuration to a Logger instance.\n *\n * @internal\n *\n * @param logger - Either \"noop\" for no logging, \"console\" for console output, or a custom Logger instance\n * @returns A Logger instance\n * @throws Error if the provided logger instance doesn't implement all required methods\n */\nexport function mapLogger(logger: undefined | \"noop\" | \"console\" | Logger): Logger {\n    if (!logger || logger === \"noop\") {\n        return noopLogger;\n    }\n\n    if (logger === \"console\") {\n        return console;\n    }\n\n    // Validate that the custom logger implements all required methods\n    for (const level of Object.keys(logLevelMap)) {\n        // Safety: level is guaranteed to be a key of Logger due to the loop over logLevelMap\n        const logMethod = logger[level as LogLevel];\n        if (typeof logMethod !== \"function\") {\n            throw new Error(`Logger method '${level}' is not available on the provided logger instance.`);\n        }\n    }\n\n    return logger;\n}\n\n/**\n * A no-op logger that discards all log messages.\n * Useful when logging should be disabled entirely.\n *\n * @internal\n */\nexport const noopLogger: Logger = {\n    error: () => {},\n    warn: () => {},\n    info: () => {},\n    debug: () => {},\n};\n"]}